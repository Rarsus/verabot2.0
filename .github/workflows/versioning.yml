name: Versioning - Semantic Release Management

on:
  push:
    branches: [main]
    paths-ignore:
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (auto, patch, minor, major)'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: read

jobs:
  analyze-commits:
    name: "Analyze Commits for Version"
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    outputs:
      current-version: ${{ steps.version.outputs.current-version }}
      new-version: ${{ steps.version.outputs.new-version }}
      release-type: ${{ steps.version.outputs.release-type }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: ğŸ·ï¸ Get current version
        id: current
        run: |
          CURRENT_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "Current version: ${CURRENT_VERSION}"

      - name: ğŸ“ Analyze commits
        id: version
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          echo "Analyzing commits in range: $COMMIT_RANGE"
          
          # Analyze commit types (supports both conventional formats)
          # Matches: feat(scope): ... or feat: ...
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -c "BREAKING CHANGE\|breaking:" || echo "0")
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^feat(\(|:)" || echo "0")
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^fix(\(|:)" || echo "0")
          
          echo "Breaking changes: $BREAKING"
          echo "Features: $FEATURES"
          echo "Fixes: $FIXES"
          
          # Determine version bump
          CURRENT_VERSION=${{ steps.current.outputs.current-version }}
          # Default to "auto" for push events, use input for manual workflow_dispatch
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          if [ -z "$RELEASE_TYPE" ] || [ "$RELEASE_TYPE" = "null" ]; then
            RELEASE_TYPE="auto"
          fi
          
          if [ "$RELEASE_TYPE" = "auto" ]; then
            if [ "$BREAKING" -gt 0 ]; then
              RELEASE_TYPE="major"
            elif [ "$FEATURES" -gt 0 ]; then
              RELEASE_TYPE="minor"
            elif [ "$FIXES" -gt 0 ]; then
              RELEASE_TYPE="patch"
            else
              RELEASE_TYPE="none"
            fi
          fi
          
          echo "Release type: $RELEASE_TYPE"
          
          # Calculate new version using npm version (dry-run)
          if [ "$RELEASE_TYPE" != "none" ]; then
            # Run npm version to calculate new version
            NPM_OUTPUT=$(npm version $RELEASE_TYPE --no-git-tag-version 2>&1)
            EXTRACT_VERSION=$(echo "$NPM_OUTPUT" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
            
            if [ -z "$EXTRACT_VERSION" ]; then
              echo "ERROR: Failed to extract version from npm output: $NPM_OUTPUT"
              exit 1
            fi
            
            # Validate the extracted version is proper semver
            if ! [[ "$EXTRACT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid semver format extracted: '$EXTRACT_VERSION' (expected X.Y.Z)"
              exit 1
            fi
            
            NEW_VERSION="$EXTRACT_VERSION"
            git checkout package.json package-lock.json 2>/dev/null || true
            SHOULD_RELEASE="true"
          else
            NEW_VERSION=""
            SHOULD_RELEASE="false"
          fi
          
          echo "New version: $NEW_VERSION"
          echo ""
          
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Generate changelog
        id: changelog
        if: steps.version.outputs.should-release == 'true'
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEW_VERSION=${{ steps.version.outputs.new-version }}
          RELEASE_TYPE=${{ steps.version.outputs.release-type }}
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          cat > /tmp/changelog.txt <<CHANGELOG_EOF
          ## [${NEW_VERSION}] - $(date +%Y-%m-%d)
          
          ### ${RELEASE_TYPE^} Release
          CHANGELOG_EOF
          
          # Breaking changes
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -A2 "BREAKING CHANGE" | grep -v "^--$" | sort -u)
          if [ ! -z "$BREAKING" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ğŸš¨ Breaking Changes
          ${BREAKING}
          CHANGELOG_EOF
          fi
          
          # Features (supports both feat(scope): and feat: formats)
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- feat(\(|:)" | sort -u)
          if [ ! -z "$FEATURES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### âœ¨ Features
          ${FEATURES}
          CHANGELOG_EOF
          fi
          
          # Fixes (supports both fix(scope): and fix: formats)
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- fix(\(|:)" | sort -u)
          if [ ! -z "$FIXES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ğŸ› Bug Fixes
          ${FIXES}
          CHANGELOG_EOF
          fi
          
          # Performance
          PERF=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep "^- perf(" | sort -u)
          if [ ! -z "$PERF" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### âš¡ Performance
          ${PERF}
          CHANGELOG_EOF
          fi
          
          # Save changelog to output
          CHANGELOG=$(cat /tmp/changelog.txt)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Generated changelog:"
          cat /tmp/changelog.txt

      - name: ğŸ“Š Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.current-version }}';
            const newVersion = '${{ steps.version.outputs.new-version }}';
            const releaseType = '${{ steps.version.outputs.release-type }}';
            const shouldRelease = '${{ steps.version.outputs.should-release }}' === 'true';
            
            let summary = '## ğŸ“¦ Version Analysis\n\n';
            summary += `**Current Version**: ${currentVersion}\n`;
            summary += `**Release Type**: ${releaseType}\n`;
            
            if (shouldRelease) {
              summary += `**New Version**: ${newVersion} âœ…\n`;
              summary += '\n**This will trigger a new release.**\n';
            } else {
              summary += '\n**No version bump required.**\n';
              summary += 'No breaking changes, features, or fixes detected since last release.\n';
            }
            
            core.notice(summary);

  create-release:
    name: "Create Release"
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should-release == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: ğŸ”§ Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: ğŸ“ Update version in package.json
        run: |
          RELEASE_TYPE=${{ needs.analyze-commits.outputs.release-type }}
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          
          echo "Release type: $RELEASE_TYPE"
          echo "Expected new version: $NEW_VERSION"
          
          # Use release type (major/minor/patch) with npm version to update package.json
          npm version $RELEASE_TYPE --no-git-tag-version
          
          # Verify the version was updated correctly
          UPDATED_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "Actual updated version: $UPDATED_VERSION"
          
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "ERROR: Version mismatch! Expected $NEW_VERSION but got $UPDATED_VERSION"
            exit 1
          fi
          
          echo "âœ… Version successfully updated to $UPDATED_VERSION"

      - name: ğŸ·ï¸ Create git tag
        id: tag
        run: |
          set -e  # Exit on first error
          
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          TAG="v${NEW_VERSION}"
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ·ï¸  GIT TAG CREATION"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Validate NEW_VERSION is proper semver
          if ! [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Invalid version tag: '$NEW_VERSION' (expected X.Y.Z format)"
            exit 1
          fi
          
          # Verify package.json has correct version
          PACKAGE_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          if [ "$PACKAGE_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ ERROR: package.json version ($PACKAGE_VERSION) doesn't match new version ($NEW_VERSION)"
            exit 1
          fi
          
          echo "âœ“ Version validation passed: $NEW_VERSION"
          
          # Check current git status before commit
          echo ""
          echo "ğŸ“ Current git status:"
          git status --short
          
          # Commit version changes
          echo ""
          echo "ğŸ’¾ Committing version changes..."
          git add package.json package-lock.json
          if git commit -m "chore: release version $NEW_VERSION"; then
            echo "âœ“ Commit created successfully"
            COMMIT_CREATED=true
          else
            echo "âš ï¸  No changes to commit (files already updated)"
            COMMIT_CREATED=false
          fi
          
          # Push the commit to the main branch with explicit error handling
          echo ""
          echo "ğŸ“¤ Pushing commit to origin/main..."
          echo "Current branch: $(git branch --show-current)"
          echo "Remote: $(git config --get remote.origin.url)"
          
          if git push origin HEAD:main 2>&1; then
            echo "âœ“ Successfully pushed commit to origin/main"
            PUSH_SUCCESS=true
          else
            PUSH_ERROR=$?
            echo "âŒ FAILED to push commit to origin/main (exit code: $PUSH_ERROR)"
            echo "Attempting to diagnose the issue..."
            
            # Diagnostic information
            echo ""
            echo "ğŸ“Š Git log (last 5 commits):"
            git log --oneline -5 || echo "Failed to get git log"
            
            echo ""
            echo "ğŸ“Š Remote info:"
            git remote -v || echo "Failed to get remotes"
            
            echo ""
            echo "ğŸ“Š Current HEAD:"
            git rev-parse HEAD || echo "Failed to get HEAD"
            
            PUSH_SUCCESS=false
          fi
          
          # Check if tag already exists
          echo ""
          echo "ğŸ·ï¸  Checking for existing tag: $TAG"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $TAG already exists, skipping tag creation"
            echo "tag-exists=true" >> $GITHUB_OUTPUT
            TAG_CREATED=false
          else
            # Create and push the tag
            echo "ğŸ“ Creating tag $TAG..."
            if git tag -a "$TAG" -m "Release version $NEW_VERSION"; then
              echo "âœ“ Tag created locally: $TAG"
              
              echo "ğŸ“¤ Pushing tag to origin..."
              if git push origin "$TAG" 2>&1; then
                echo "âœ“ Successfully pushed tag to origin"
                echo "tag-exists=false" >> $GITHUB_OUTPUT
                TAG_CREATED=true
              else
                TAG_PUSH_ERROR=$?
                echo "âŒ FAILED to push tag (exit code: $TAG_PUSH_ERROR)"
                TAG_CREATED=false
                exit 1
              fi
            else
              echo "âŒ FAILED to create tag"
              exit 1
            fi
          fi
          
          # Summary
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š SUMMARY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Tag: $TAG"
          echo "Commit pushed: $PUSH_SUCCESS"
          echo "Tag created: $TAG_CREATED"
          
          if [ "$PUSH_SUCCESS" = false ]; then
            echo ""
            echo "âš ï¸  WARNING: Commit was not successfully pushed to origin/main!"
            echo "The tag was still created, but manual intervention may be needed."
            echo "Check the logs above for error details."
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: âœ… Validate Release Integrity
        id: validate
        shell: bash
        run: |
          set -e
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” VALIDATING RELEASE INTEGRITY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          TAG="v${{ needs.analyze-commits.outputs.new-version }}"
          
          # Check 1: Local tag exists
          echo ""
          echo "âœ“ Checking local tag..."
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "  âœ… Local tag exists: $TAG"
            echo "local_tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "  âŒ Local tag MISSING: $TAG"
            echo "local_tag_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # Check 2: Remote tag exists
          echo ""
          echo "âœ“ Checking remote tag..."
          git fetch origin refs/tags/$TAG:refs/tags/$TAG 2>/dev/null || true
          if git rev-parse $TAG >/dev/null 2>&1; then
            echo "  âœ… Remote tag exists: $TAG"
            echo "remote_tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "  âš ï¸  Remote tag NOT found (may sync shortly)"
            echo "remote_tag_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # Check 3: Chore commit exists locally
          echo ""
          echo "âœ“ Checking chore commit..."
          CHORE_FOUND=$(git log --oneline -20 | grep -c "chore: release" || echo 0)
          if [ "$CHORE_FOUND" -gt 0 ]; then
            CHORE_COMMIT=$(git log --oneline -20 | grep "chore: release" | head -1)
            echo "  âœ… Chore commit found: $CHORE_COMMIT"
            echo "chore_commit_exists=true" >> $GITHUB_OUTPUT
          else
            echo "  âš ï¸  Chore commit NOT in recent history"
            echo "chore_commit_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # Check 4: package.json version matches
          echo ""
          echo "âœ“ Checking version sync..."
          PKG_VERSION=$(grep '"version"' package.json | head -1 | cut -d'"' -f4)
          EXPECTED_VERSION="${{ needs.analyze-commits.outputs.new-version }}"
          if [ "$PKG_VERSION" = "$EXPECTED_VERSION" ]; then
            echo "  âœ… package.json version matches: $PKG_VERSION"
            echo "version_sync=true" >> $GITHUB_OUTPUT
          else
            echo "  âŒ Version mismatch! Expected: $EXPECTED_VERSION, Found: $PKG_VERSION"
            echo "version_sync=false" >> $GITHUB_OUTPUT
          fi
          
          # Summary
          echo ""
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "ğŸ“Š VALIDATION SUMMARY"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          LOCAL_TAG=$(cat $GITHUB_OUTPUT | grep "local_tag_exists=" | cut -d'=' -f2)
          REMOTE_TAG=$(cat $GITHUB_OUTPUT | grep "remote_tag_exists=" | cut -d'=' -f2)
          CHORE=$(cat $GITHUB_OUTPUT | grep "chore_commit_exists=" | cut -d'=' -f2)
          VERSION=$(cat $GITHUB_OUTPUT | grep "version_sync=" | cut -d'=' -f2)
          
          echo "Local tag:        $([ "$LOCAL_TAG" = "true" ] && echo "âœ…" || echo "âŒ")"
          echo "Remote tag:       $([ "$REMOTE_TAG" = "true" ] && echo "âœ…" || echo "âš ï¸ ")"
          echo "Chore commit:     $([ "$CHORE" = "true" ] && echo "âœ…" || echo "âš ï¸ ")"
          echo "Version sync:     $([ "$VERSION" = "true" ] && echo "âœ…" || echo "âŒ")"
          
          if [ "$LOCAL_TAG" = "false" ] || [ "$VERSION" = "false" ]; then
            echo ""
            echo "âš ï¸  CRITICAL: Release integrity check failed!"
            exit 1
          fi
          
          echo ""
          echo "âœ… All critical checks passed"

      - name: ğŸ“š Create GitHub Release
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const changelogText = `${{ needs.analyze-commits.outputs.changelog }}`;
            const tag = 'v' + newVersion;
            const tagExists = '${{ steps.tag.outputs.tag-exists }}' === 'true';
            
            try {
              // Check if release already exists
              let release;
              try {
                const existingRelease = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tag
                });
                
                if (existingRelease && existingRelease.status === 200) {
                  core.info(`Release for ${tag} already exists, updating it`);
                  release = await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: existingRelease.data.id,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                }
              } catch (getReleaseError) {
                // Release doesn't exist, create it
                if (getReleaseError.status === 404 || !tagExists) {
                  core.info(`Creating new release for ${tag}`);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                } else {
                  throw getReleaseError;
                }
              }
              
              core.setOutput('release_url', release.data.html_url);
              core.notice(`âœ… Release processed: ${release.data.html_url}`);
            } catch (error) {
              core.warning(`Release processing warning: ${error.message}`);
            }

      - name: ğŸ“¢ Announce Release
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const releaseType = '${{ needs.analyze-commits.outputs.release-type }}';
            const releaseUrl = '${{ steps.release.outputs.release_url }}';
            
            let announcement = `## ğŸ‰ New Release: ${newVersion}\n\n`;
            announcement += `**Type**: ${releaseType}\n`;
            announcement += `**Release**: [${newVersion}](${releaseUrl})\n\n`;
            announcement += `### What's New\n`;
            announcement += `${{ needs.analyze-commits.outputs.changelog }}\n`;
            
            core.notice(announcement);

  notify-completion:
    name: "Notify Completion"
    runs-on: ubuntu-latest
    needs: [analyze-commits, create-release]
    if: always()

    steps:
      - name: ğŸ“Š Final Status
        uses: actions/github-script@v7
        with:
          script: |
            const analyzeResult = '${{ needs.analyze-commits.result }}';
            const createResult = '${{ needs.create-release.result }}';
            const validateResult = '${{ needs.create-release.result }}';
            
            let summary = '## ğŸ“¦ Versioning Workflow Complete\n\n';
            
            if (analyzeResult === 'success') {
              const shouldRelease = '${{ needs.analyze-commits.outputs.should-release }}' === 'true';
              
              if (shouldRelease) {
                summary += 'âœ… Version Analysis: Complete\n';
                summary += `ğŸ“ New Version: ${{ needs.analyze-commits.outputs.new-version }}\n`;
                
                if (createResult === 'success') {
                  summary += 'âœ… Release Created: Success\n';
                  summary += 'ğŸ·ï¸ Git Tag: Created\n';
                  summary += 'ğŸ“š GitHub Release: Published\n';
                  
                  // Add validation status
                  const localTag = '${{ steps.validate.outputs.local_tag_exists }}' === 'true';
                  const remoteTag = '${{ steps.validate.outputs.remote_tag_exists }}' === 'true';
                  const choreCommit = '${{ steps.validate.outputs.chore_commit_exists }}' === 'true';
                  const versionSync = '${{ steps.validate.outputs.version_sync }}' === 'true';
                  
                  summary += '\n### Integrity Validation\n';
                  summary += `${localTag ? 'âœ…' : 'âŒ'} Local tag created\n`;
                  summary += `${remoteTag ? 'âœ…' : 'âš ï¸'} Remote tag synced\n`;
                  summary += `${choreCommit ? 'âœ…' : 'âš ï¸'} Chore commit exists\n`;
                  summary += `${versionSync ? 'âœ…' : 'âŒ'} Version synchronized\n`;
                  
                  if (!versionSync) {
                    summary += '\nâš ï¸ **ACTION REQUIRED**: Version sync failed. See logs for details.\n';
                  }
                } else {
                  summary += 'âš ï¸ Release Creation: Failed\n';
                  summary += 'Please check the logs above.\n';
                }
              } else {
                summary += 'âœ… No version bump required\n';
                summary += 'No breaking changes or new features detected.\n';
              }
            } else {
              summary += 'âŒ Version Analysis Failed\n';
            }
            
            core.notice(summary);

name: Versioning - Semantic Release Management

on:
  push:
    branches: [main]
    paths-ignore:
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (auto, patch, minor, major)'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: read

jobs:
  analyze-commits:
    name: "Analyze Commits for Version"
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    outputs:
      current-version: ${{ steps.version.outputs.current-version }}
      new-version: ${{ steps.version.outputs.new-version }}
      release-type: ${{ steps.version.outputs.release-type }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: üè∑Ô∏è Get current version
        id: current
        run: |
          CURRENT_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "Current version: ${CURRENT_VERSION}"

      - name: üìù Analyze commits
        id: version
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          echo "Analyzing commits in range: $COMMIT_RANGE"
          
          # Analyze commit types (supports both conventional formats)
          # Matches: feat(scope): ... or feat: ...
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -c "BREAKING CHANGE\|breaking:" || echo "0")
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^feat(\(|:)" || echo "0")
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^fix(\(|:)" || echo "0")
          
          echo "Breaking changes: $BREAKING"
          echo "Features: $FEATURES"
          echo "Fixes: $FIXES"
          
          # Determine version bump
          CURRENT_VERSION=${{ steps.current.outputs.current-version }}
          # Default to "auto" for push events, use input for manual workflow_dispatch
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          if [ -z "$RELEASE_TYPE" ] || [ "$RELEASE_TYPE" = "null" ]; then
            RELEASE_TYPE="auto"
          fi
          
          if [ "$RELEASE_TYPE" = "auto" ]; then
            if [ "$BREAKING" -gt 0 ]; then
              RELEASE_TYPE="major"
            elif [ "$FEATURES" -gt 0 ]; then
              RELEASE_TYPE="minor"
            elif [ "$FIXES" -gt 0 ]; then
              RELEASE_TYPE="patch"
            else
              RELEASE_TYPE="none"
            fi
          fi
          
          echo "Release type: $RELEASE_TYPE"
          
          # Calculate new version using npm version (dry-run)
          if [ "$RELEASE_TYPE" != "none" ]; then
            # Run npm version to calculate new version
            NPM_OUTPUT=$(npm version $RELEASE_TYPE --no-git-tag-version 2>&1)
            EXTRACT_VERSION=$(echo "$NPM_OUTPUT" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
            
            if [ -z "$EXTRACT_VERSION" ]; then
              echo "ERROR: Failed to extract version from npm output: $NPM_OUTPUT"
              exit 1
            fi
            
            # Validate the extracted version is proper semver
            if ! [[ "$EXTRACT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid semver format extracted: '$EXTRACT_VERSION' (expected X.Y.Z)"
              exit 1
            fi
            
            NEW_VERSION="$EXTRACT_VERSION"
            git checkout package.json package-lock.json 2>/dev/null || true
            SHOULD_RELEASE="true"
          else
            NEW_VERSION=""
            SHOULD_RELEASE="false"
          fi
          
          echo "New version: $NEW_VERSION"
          echo ""
          
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: üìã Generate changelog
        id: changelog
        if: steps.version.outputs.should-release == 'true'
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEW_VERSION=${{ steps.version.outputs.new-version }}
          RELEASE_TYPE=${{ steps.version.outputs.release-type }}
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          cat > /tmp/changelog.txt <<CHANGELOG_EOF
          ## [${NEW_VERSION}] - $(date +%Y-%m-%d)
          
          ### ${RELEASE_TYPE^} Release
          CHANGELOG_EOF
          
          # Breaking changes
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -A2 "BREAKING CHANGE" | grep -v "^--$" | sort -u)
          if [ ! -z "$BREAKING" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### üö® Breaking Changes
          ${BREAKING}
          CHANGELOG_EOF
          fi
          
          # Features (supports both feat(scope): and feat: formats)
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- feat(\(|:)" | sort -u)
          if [ ! -z "$FEATURES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ‚ú® Features
          ${FEATURES}
          CHANGELOG_EOF
          fi
          
          # Fixes (supports both fix(scope): and fix: formats)
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- fix(\(|:)" | sort -u)
          if [ ! -z "$FIXES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### üêõ Bug Fixes
          ${FIXES}
          CHANGELOG_EOF
          fi
          
          # Performance
          PERF=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep "^- perf(" | sort -u)
          if [ ! -z "$PERF" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ‚ö° Performance
          ${PERF}
          CHANGELOG_EOF
          fi
          
          # Save changelog to output
          CHANGELOG=$(cat /tmp/changelog.txt)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Generated changelog:"
          cat /tmp/changelog.txt

      - name: üìä Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.current-version }}';
            const newVersion = '${{ steps.version.outputs.new-version }}';
            const releaseType = '${{ steps.version.outputs.release-type }}';
            const shouldRelease = '${{ steps.version.outputs.should-release }}' === 'true';
            
            let summary = '## üì¶ Version Analysis\n\n';
            summary += `**Current Version**: ${currentVersion}\n`;
            summary += `**Release Type**: ${releaseType}\n`;
            
            if (shouldRelease) {
              summary += `**New Version**: ${newVersion} ‚úÖ\n`;
              summary += '\n**This will trigger a new release.**\n';
            } else {
              summary += '\n**No version bump required.**\n';
              summary += 'No breaking changes, features, or fixes detected since last release.\n';
            }
            
            core.notice(summary);

  create-release:
    name: "Create Release"
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should-release == 'true'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: üîß Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: üìù Update version in package.json
        run: |
          RELEASE_TYPE=${{ needs.analyze-commits.outputs.release-type }}
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          
          echo "Release type: $RELEASE_TYPE"
          echo "Expected new version: $NEW_VERSION"
          
          # Use release type (major/minor/patch) with npm version to update package.json
          npm version $RELEASE_TYPE --no-git-tag-version
          
          # Verify the version was updated correctly
          UPDATED_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "Actual updated version: $UPDATED_VERSION"
          
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "ERROR: Version mismatch! Expected $NEW_VERSION but got $UPDATED_VERSION"
            exit 1
          fi
          
          echo "‚úÖ Version successfully updated to $UPDATED_VERSION"

      - name: üè∑Ô∏è Create git tag
        id: tag
        run: |
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          TAG="v${NEW_VERSION}"
          
          # Validate NEW_VERSION is proper semver
          if ! [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid version tag: '$NEW_VERSION' (expected X.Y.Z format)"
            exit 1
          fi
          
          # Verify package.json has correct version
          PACKAGE_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          if [ "$PACKAGE_VERSION" != "$NEW_VERSION" ]; then
            echo "ERROR: package.json version ($PACKAGE_VERSION) doesn't match new version ($NEW_VERSION)"
            exit 1
          fi
          
          git add package.json package-lock.json
          git commit -m "chore: release version $NEW_VERSION" || true
          
          # Push the commit to the main branch
          git push origin HEAD:main
          
          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag $TAG already exists, skipping tag creation"
            echo "tag-exists=true" >> $GITHUB_OUTPUT
          else
            git tag -a "$TAG" -m "Release version $NEW_VERSION"
            git push origin "$TAG"
            echo "tag-exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Created and pushed tag: $TAG"
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: üìö Create GitHub Release
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const changelogText = `${{ needs.analyze-commits.outputs.changelog }}`;
            const tag = 'v' + newVersion;
            const tagExists = '${{ steps.tag.outputs.tag-exists }}' === 'true';
            
            try {
              // Check if release already exists
              let release;
              try {
                const existingRelease = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tag
                });
                
                if (existingRelease && existingRelease.status === 200) {
                  core.info(`Release for ${tag} already exists, updating it`);
                  release = await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: existingRelease.data.id,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                }
              } catch (getReleaseError) {
                // Release doesn't exist, create it
                if (getReleaseError.status === 404 || !tagExists) {
                  core.info(`Creating new release for ${tag}`);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                } else {
                  throw getReleaseError;
                }
              }
              
              core.setOutput('release_url', release.data.html_url);
              core.notice(`‚úÖ Release processed: ${release.data.html_url}`);
            } catch (error) {
              core.warning(`Release processing warning: ${error.message}`);
            }

      - name: üì¢ Announce Release
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const releaseType = '${{ needs.analyze-commits.outputs.release-type }}';
            const releaseUrl = '${{ steps.release.outputs.release_url }}';
            
            let announcement = `## üéâ New Release: ${newVersion}\n\n`;
            announcement += `**Type**: ${releaseType}\n`;
            announcement += `**Release**: [${newVersion}](${releaseUrl})\n\n`;
            announcement += `### What's New\n`;
            announcement += `${{ needs.analyze-commits.outputs.changelog }}\n`;
            
            core.notice(announcement);

  notify-completion:
    name: "Notify Completion"
    runs-on: ubuntu-latest
    needs: [analyze-commits, create-release]
    if: always()

    steps:
      - name: üìä Final Status
        uses: actions/github-script@v7
        with:
          script: |
            const analyzeResult = '${{ needs.analyze-commits.result }}';
            const createResult = '${{ needs.create-release.result }}';
            
            let summary = '## üì¶ Versioning Workflow Complete\n\n';
            
            if (analyzeResult === 'success') {
              const shouldRelease = '${{ needs.analyze-commits.outputs.should-release }}' === 'true';
              
              if (shouldRelease) {
                summary += '‚úÖ Version Analysis: Complete\n';
                summary += `üìù New Version: ${{ needs.analyze-commits.outputs.new-version }}\n`;
                
                if (createResult === 'success') {
                  summary += '‚úÖ Release Created: Success\n';
                  summary += 'üè∑Ô∏è Git Tag: Created\n';
                  summary += 'üìö GitHub Release: Published\n';
                } else {
                  summary += '‚ö†Ô∏è Release Creation: Failed\n';
                  summary += 'Please check the logs above.\n';
                }
              } else {
                summary += '‚úÖ No version bump required\n';
                summary += 'No breaking changes or new features detected.\n';
              }
            } else {
              summary += '‚ùå Version Analysis Failed\n';
            }
            
            core.notice(summary);
